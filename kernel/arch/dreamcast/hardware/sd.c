/* KallistiOS ##version##

   sd.c
   Copyright (C) 2012, 2013 Lawrence Sebald
   Copyright (C) 2025 Ruslan Rostovtsev
*/

/* The code contained herein is basically directly implementing what is
   documented here: http://elm-chan.org/docs/mmc/mmc_e.html */

#include <arch/types.h>
#include <dc/scif.h>
#include <dc/sci.h>
#include <dc/sd.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* For CRC16-CCITT */
#include <kos/net.h>

#include <kos/blockdev.h>
#include <kos/dbglog.h>

#define MAX_RETRIES     500000
#define READ_RETRIES    50000
#define WRITE_RETRIES   150000

#define CMD(n) ((n) | 0x40)

static bool byte_mode = false;
static bool is_mmc = false;
static bool initted = false;
static bool check_crc = true;
static sd_interface_t current_interface = SD_IF_SCIF;

/* Unified function pointers for both interfaces */
static uint8_t (*spi_rw_byte)(uint8_t data) = NULL;
static void (*spi_set_cs)(bool enabled) = NULL;
static int (*spi_init)(bool fast) = NULL;
static void (*spi_shutdown)(void) = NULL;
static void (*spi_read_data)(uint8_t *data, size_t len) = NULL;
static void (*spi_write_data)(const uint8_t *data, size_t len) = NULL;
static uint8_t (*spi_read_byte)(void) = NULL;
static void (*spi_write_byte)(uint8_t data) = NULL;

/* The type of the dev_data in the block device structure */
typedef struct sd_devdata {
    uint64_t block_count;
    uint64_t start_block;
} sd_devdata_t;

/* Table/algorithm generated by pycrc. I really wanted to have a much smaller
   table here, but unfortunately, the code pycrc generated just did not work. */
static const uint8 crc7_table[256] = {
    0x00, 0x12, 0x24, 0x36, 0x48, 0x5a, 0x6c, 0x7e,
    0x90, 0x82, 0xb4, 0xa6, 0xd8, 0xca, 0xfc, 0xee,
    0x32, 0x20, 0x16, 0x04, 0x7a, 0x68, 0x5e, 0x4c,
    0xa2, 0xb0, 0x86, 0x94, 0xea, 0xf8, 0xce, 0xdc,
    0x64, 0x76, 0x40, 0x52, 0x2c, 0x3e, 0x08, 0x1a,
    0xf4, 0xe6, 0xd0, 0xc2, 0xbc, 0xae, 0x98, 0x8a,
    0x56, 0x44, 0x72, 0x60, 0x1e, 0x0c, 0x3a, 0x28,
    0xc6, 0xd4, 0xe2, 0xf0, 0x8e, 0x9c, 0xaa, 0xb8,
    0xc8, 0xda, 0xec, 0xfe, 0x80, 0x92, 0xa4, 0xb6,
    0x58, 0x4a, 0x7c, 0x6e, 0x10, 0x02, 0x34, 0x26,
    0xfa, 0xe8, 0xde, 0xcc, 0xb2, 0xa0, 0x96, 0x84,
    0x6a, 0x78, 0x4e, 0x5c, 0x22, 0x30, 0x06, 0x14,
    0xac, 0xbe, 0x88, 0x9a, 0xe4, 0xf6, 0xc0, 0xd2,
    0x3c, 0x2e, 0x18, 0x0a, 0x74, 0x66, 0x50, 0x42,
    0x9e, 0x8c, 0xba, 0xa8, 0xd6, 0xc4, 0xf2, 0xe0,
    0x0e, 0x1c, 0x2a, 0x38, 0x46, 0x54, 0x62, 0x70,
    0x82, 0x90, 0xa6, 0xb4, 0xca, 0xd8, 0xee, 0xfc,
    0x12, 0x00, 0x36, 0x24, 0x5a, 0x48, 0x7e, 0x6c,
    0xb0, 0xa2, 0x94, 0x86, 0xf8, 0xea, 0xdc, 0xce,
    0x20, 0x32, 0x04, 0x16, 0x68, 0x7a, 0x4c, 0x5e,
    0xe6, 0xf4, 0xc2, 0xd0, 0xae, 0xbc, 0x8a, 0x98,
    0x76, 0x64, 0x52, 0x40, 0x3e, 0x2c, 0x1a, 0x08,
    0xd4, 0xc6, 0xf0, 0xe2, 0x9c, 0x8e, 0xb8, 0xaa,
    0x44, 0x56, 0x60, 0x72, 0x0c, 0x1e, 0x28, 0x3a,
    0x4a, 0x58, 0x6e, 0x7c, 0x02, 0x10, 0x26, 0x34,
    0xda, 0xc8, 0xfe, 0xec, 0x92, 0x80, 0xb6, 0xa4,
    0x78, 0x6a, 0x5c, 0x4e, 0x30, 0x22, 0x14, 0x06,
    0xe8, 0xfa, 0xcc, 0xde, 0xa0, 0xb2, 0x84, 0x96,
    0x2e, 0x3c, 0x0a, 0x18, 0x66, 0x74, 0x42, 0x50,
    0xbe, 0xac, 0x9a, 0x88, 0xf6, 0xe4, 0xd2, 0xc0,
    0x1c, 0x0e, 0x38, 0x2a, 0x54, 0x46, 0x70, 0x62,
    0x8c, 0x9e, 0xa8, 0xba, 0xc4, 0xd6, 0xe0, 0xf2
};

uint8 sd_crc7(const uint8 *data, int size, uint8 crc) {
    int tbl_idx;

    while(size--) {
        tbl_idx = (crc ^ *data) & 0xff;
        crc = (crc7_table[tbl_idx] ^ (crc << 7)) & (0x7f << 1);

        data++;
    }

    return crc & (0x7f << 1);
}

/* Unified wrappers for different interfaces */
static uint8_t sci_rw_byte(uint8_t data) {
    uint8_t rx;
    sci_spi_rw_byte(data, &rx);
    return rx;
}

static bool current_speed = false; /* false = slow, true = fast */

static uint8_t scif_rw_byte_wrapper(uint8_t data) {
    if(current_speed)
        return scif_spi_rw_byte(data);
    else
        return scif_spi_slow_rw_byte(data);
}

static void scif_write_data_wrapper(const uint8_t *data, size_t len) {
    while(len--) {
        scif_spi_write_byte(*data++);
    }
}

static uint8_t sci_read_byte_wrapper(void) {
    uint8_t rx;
    sci_spi_read_byte(&rx);
    return rx;
}

static void sci_write_byte_wrapper(uint8_t data) {
    sci_spi_write_byte(data);
}

static void sci_read_data_wrapper(uint8_t *data, size_t len) {
    if(len & 31)
        sci_spi_read_data(data, len);
    else
        sci_spi_dma_read_data(data, len, NULL, NULL);
}

static void sci_write_data_wrapper(const uint8_t *data, size_t len) {
    if(len & 31)
        sci_spi_write_data(data, len);
    else
        sci_spi_dma_write_data(data, len, NULL, NULL);
}

static void scif_shutdown_wrapper(void) {
    scif_spi_shutdown();
}

static void sci_shutdown_wrapper(void) {
    sci_shutdown();
}

static int scif_init_wrapper(bool fast) {
    current_speed = fast;
    return scif_spi_init();
}

static void scif_set_cs_wrapper(bool enabled) {
    scif_spi_set_cs(enabled ? 0 : 1);
}

static int sci_init_wrapper(bool fast) {
    uint32_t baud = fast ? SCI_SPI_BAUD_MAX : SCI_SPI_BAUD_INIT;
    return sci_init(baud, SCI_MODE_SPI, SCI_CLK_INT);
}

static int sd_send_cmd(uint8_t cmd, uint32 arg) {
    uint8 rv;
    int i = 0;
    uint8 pkt[6];

    /* Wait for the SD card to be ready to accept our command... */
    spi_rw_byte(0xFF);
    do {
        rv = spi_rw_byte(0xFF);
        ++i;
    } while(rv != 0xFF && i < MAX_RETRIES);

    /* If we never got a response, something's wrong... bail out */
    if(rv != 0xFF)
        return -1;

    /* Pack up the packet */
    pkt[0] = cmd;
    pkt[1] = (uint8)(arg >> 24);
    pkt[2] = (uint8)(arg >> 16);
    pkt[3] = (uint8)(arg >>  8);
    pkt[4] = (uint8)(arg >>  0);
    pkt[5] = sd_crc7(pkt, 5, 0) | 0x01;

    /* Write out the packet to the device */
    spi_rw_byte(pkt[0]);
    spi_rw_byte(pkt[1]);
    spi_rw_byte(pkt[2]);
    spi_rw_byte(pkt[3]);
    spi_rw_byte(pkt[4]);
    spi_rw_byte(pkt[5]);

    /* Ignore the first byte after sending a CMD12 */
    if(cmd == CMD(12))
        spi_rw_byte(0xFF);

    /* Wait for a response */
    i = 0;
    do {
        rv = spi_rw_byte(0xFF);
        ++i;
    } while((rv & 0x80) && i < 20);

    if(rv & 0x80)
        return -1;

    return (int)rv;
}

static int acmd41_loop(uint32 arg) {
    int i = 0, rv;

    /* Try to send ACMD41 for a while. It could take up to 1 second to come
       back to us, but will likely take much less. */
    while(i++ < MAX_RETRIES) {
        if(sd_send_cmd(CMD(55), 0) > 1)
            return -1;

        if((rv = sd_send_cmd(CMD(41), arg)) > 1)
            return -1;

        if(rv == 0)
            break;
    }

    /* If we get this far, it isn't going to come back. */
    if(i == MAX_RETRIES)
        return -2;

    return 0;
}

static int cmd1_loop(void) {
    int i = 0, rv;

    /* Try to send CMD1 for a while. It could take up to 1 second to come
       back to us, but will likely take much less. */
    while(i++ < MAX_RETRIES) {
        if((rv = sd_send_cmd(CMD(1), 0)) > 1)
            return -1;

        if(rv == 0)
            break;
    }

    /* If we get this far, it isn't going to come back. */
    if(i == MAX_RETRIES)
        return -2;

    return 0;
}

int sd_init(void) {
    sd_init_params_t params = {
        .interface = SD_IF_SCIF,
        .check_crc = true
    };
    return sd_init_ex(&params);
}

int sd_init_ex(const sd_init_params_t *params) {
    int i;
    uint8 buf[4];

    if(initted)
        return 0;

    if(!params) {
        errno = EINVAL;
        return -1;
    }

    byte_mode = is_mmc = false;
    check_crc = params->check_crc;
    current_interface = params->interface;

    if(current_interface == SD_IF_SCIF) {
        spi_rw_byte = &scif_rw_byte_wrapper;
        spi_set_cs = &scif_set_cs_wrapper;
        spi_init = &scif_init_wrapper;
        spi_shutdown = &scif_shutdown_wrapper;
        spi_read_data = &scif_spi_read_data;
        spi_write_data = &scif_write_data_wrapper;
        spi_read_byte = &scif_spi_read_byte;
        spi_write_byte = &scif_spi_write_byte;
    }
    else {
        spi_rw_byte = &sci_rw_byte;
        spi_set_cs = &sci_spi_set_cs;
        spi_init = &sci_init_wrapper;
        spi_shutdown = &sci_shutdown_wrapper;
        spi_read_data = &sci_read_data_wrapper;
        spi_write_data = &sci_write_data_wrapper;
        spi_read_byte = &sci_read_byte_wrapper;
        spi_write_byte = &sci_write_byte_wrapper;
    }

    /* Initialize interface with low speed for reliability */
    if(spi_init(false))
        return -1;

    /* Send 10 idle bytes so as to delay the required number of clock cycles
       after asserting the /CS pin (we have to delay at least 74 clock cycles,
       and sending 10 idle bytes is 80 cycles). Once that is done, deassert the
       /CS line. */
    for(i = 0; i < 10; ++i) {
        spi_rw_byte(0xFF);
    }

    spi_set_cs(true);

    /* Reset the card, putting it in its idle state. */
    if(sd_send_cmd(CMD(0), 0) != 1) {
        spi_set_cs(false);
        return -1;
    }

    /* Detect if we're using a v2 SD card. */
    if(sd_send_cmd(CMD(8), 0x000001AA) == 1) {
        buf[0] = spi_rw_byte(0xFF);
        buf[1] = spi_rw_byte(0xFF);
        buf[2] = spi_rw_byte(0xFF);
        buf[3] = spi_rw_byte(0xFF);

        if((buf[2] & 0x0F) != 0x01 || buf[3] != 0xAA) {
            spi_set_cs(false);
            return -2;
        }

        /* ACMD41 until we're ready */
        if(acmd41_loop(0x40000000)) {
            spi_set_cs(false);
            return -1;
        }

        /* Detect if we do byte addressing or block addressing with CMD58 */
        if(sd_send_cmd(CMD(58), 0)) {
            spi_set_cs(false);
            return -1;
        }

        buf[0] = spi_rw_byte(0xFF);
        buf[1] = spi_rw_byte(0xFF);
        buf[2] = spi_rw_byte(0xFF);
        buf[3] = spi_rw_byte(0xFF);

        if(!(buf[0] & 0x40))
            byte_mode = true;
    }
    else {
        /* ACMD41 (SDv1) or CMD1 (MMC) until we're ready */
        if(acmd41_loop(0)) {
            /* Try with CMD1 instead then... */
            if(cmd1_loop()) {
                spi_set_cs(false);
                return -1;
            }

            /* If ACMD41 failed but CMD1 succeeded, we have a MMC card. */
            is_mmc = true;
        }

        /* Set the block length to 512 with CMD16 */
        if(sd_send_cmd(CMD(16), 512)) {
            spi_set_cs(false);
            return -1;
        }

        /* v1 cards always use byte addressing. */
        byte_mode = true;
    }

    /* Re-enable CRC checking. */
    if(sd_send_cmd(CMD(59), 1)) {
        spi_set_cs(false);
        return -1;
    }

    /* Make sure that the card releases the data line */
    spi_set_cs(false);
    spi_rw_byte(0xFF);

    /* Switch to maximum speed after successful initialization */
    if(spi_init(true))
        return -1;

    initted = true;

    return 0;
}

int sd_shutdown(void) {
    int i = 0;
    uint8 rv;

    if(!initted)
        return -1;

    /* Select, wait for ready, deselect, and make sure it releases the data
       line. */
    spi_set_cs(true);

    spi_rw_byte(0xFF);
    do {
        rv = spi_rw_byte(0xFF);
        ++i;
    } while(rv != 0xFF && i < MAX_RETRIES);

    spi_set_cs(false);
    spi_rw_byte(0xFF);
    spi_shutdown();
    initted = false;

    return 0;
}

static int read_data(size_t bytes, uint8 *buf) {
    uint8 byte;
    uint16 crc;
    int i = 0;

    /* This should come back in 100ms at worst... */
    do {
        byte = spi_rw_byte(0xFF);
        ++i;
    } while(byte == 0xFF && i < READ_RETRIES);

    if(byte != 0xFE)
        return -1;

    /* Read in the data */
    spi_read_data(buf, bytes);

    /* Read in the trailing CRC */
    if(check_crc) {
        crc = (spi_read_byte() << 8) | spi_read_byte();
        return crc != net_crc16ccitt(buf, bytes, 0);
    }
    else {
        (void)spi_read_byte();
        (void)spi_read_byte();
        return 0;
    }
}

int sd_read_blocks(uint32 block, size_t count, uint8 *buf) {
    int rv = 0;

    if(!initted) {
        errno = ENXIO;
        return -1;
    }

    /* If we're in byte addressing mode, scale the block up. */
    if(byte_mode)
        block <<= 9;

    spi_set_cs(true);

    if(count == 1) {
        /* Ask the card for the block */
        if(sd_send_cmd(CMD(17), block)) {
            rv = -1;
            errno = EIO;
            goto out;
        }

        /* Read the block back */
        if(read_data(512, buf)) {
            rv = -1;
            errno = EIO;
            goto out;
        }
    }
    else {
        /* Set up the multi-block read */
        if(sd_send_cmd(CMD(18), block)) {
            rv = -1;
            errno = EIO;
            goto out;
        }

        while(count--) {
            if(read_data(512, buf)) {
                rv = -1;
                errno = EIO;
                goto out;
            }

            buf += 512;
        }

        /* Stop the data transfer */
        sd_send_cmd(CMD(12), 0);
    }

out:
    spi_set_cs(false);
    spi_rw_byte(0xFF);

    return rv;
}

static int write_data(uint8 tag, size_t bytes, const uint8 *buf) {
    uint8 rv;
    int i = 0;
    uint16 crc;
    const uint8 *ptr = buf;

    /* Wait for the card to be ready for our data */
    spi_rw_byte(0xFF);
    do {
        rv = spi_rw_byte(0xFF);
        ++i;
    } while(rv != 0xFF && i < WRITE_RETRIES);

    if(rv != 0xFF)
        return -1;

    spi_write_byte(tag);

    /* Send the data. */
    crc = net_crc16ccitt(buf, bytes, 0);
    while(bytes--) {
        spi_write_byte(*ptr++);
    }

    /* Write out the block's crc */
    spi_write_byte((uint8)(crc >> 8));
    spi_write_byte((uint8)crc);

    /* Make sure the card accepted the block */
    rv = spi_read_byte();
    if((rv & 0x1F) != 0x05)
        return -1;

    return 0;
}

int sd_write_blocks(uint32 block, size_t count, const uint8 *buf) {
    int rv = 0, i = 0;
    uint8 byte;

    if(!initted) {
        errno = ENXIO;
        return -1;
    }

    /* If we're in byte addressing mode, scale the block up. */
    if(byte_mode)
        block <<= 9;

    spi_set_cs(true);

    if(count == 1) {
        /* Prepare the card for the block */
        if(sd_send_cmd(CMD(24), block)) {
            rv = -1;
            errno = EIO;
            goto out;
        }

        /* Read the block back */
        if(write_data(0xFE, 512, buf)) {
            rv = -1;
            errno = EIO;
            goto out;
        }
    }
    else {
        /* If we're on a SD card, inform the card ahead of time how many blocks
           we intend to write. */
        if(!is_mmc) {
            sd_send_cmd(CMD(55), 0);
            sd_send_cmd(CMD(23), count);
        }

        /* Set up the multi-block write */
        if(sd_send_cmd(CMD(25), block)) {
            rv = -1;
            errno = EIO;
            goto out;
        }

        while(count--) {
            if(write_data(0xFC, 512, buf)) {
                /* Make sure we at least try to stop the transfer... */
                rv = -1;
                errno = EIO;
                break;
            }

            buf += 512;
        }

        /* Write the end data token. */
        spi_rw_byte(0xFF);
        do {
            byte = spi_rw_byte(0xFF);
            ++i;
        } while(byte != 0xFF && i < WRITE_RETRIES);

        if(byte != 0xFF) {
            rv = -1;
            errno = EIO;
            goto out;
        }

        spi_rw_byte(0xFD);
    }

out:
    spi_set_cs(false);
    spi_rw_byte(0xFF);

    return rv;
}

uint64 sd_get_size(void) {
    uint8 csd[16];
    uint64 rv;
    int exponent;

    if(!initted) {
        errno = ENXIO;
        return (uint64)-1;
    }

    /* In order to get the size of the SD card, we must read the CSD register
       via CMD9. There are two different versions of the CSD structure, one of
       which is used on normal SD cards, and one that is used on SDHC and SDXC
       cards. Each one has a slightly different way of calculating the card
       size. The procedure here is described on pages 96-105 of the SD Physical
       Layer Simplified Specification v3.01. */

    /* Prepare the CSD send */
    spi_set_cs(true);
    if(sd_send_cmd(CMD(9), 0)) {
        rv = (uint64)-1;
        errno = EIO;
        goto out;
    }

    /* Read back the register */
    if(read_data(16, csd)) {
        rv = (uint64)-1;
        errno = EIO;
        goto out;
    }

    /* Figure out what version of the CSD register we're looking at */
    switch(csd[0] >> 6) {
        case 0:
            /* CSD version 1.0 (SD)
               C_SIZE is bits 62-73 of the CSD, C_SIZE_MULT is bits 47-49,
               READ_BL_LEN is bits 80-83.
               Card size is calculated as follows:
               (C_SIZE + 1) * 2^(C_SIZE_MULT + 2) * 2^(READ_BL_LEN) */
            exponent = (csd[5] & 0x0F) + ((csd[9] & 0x03) << 1) +
                (csd[10] >> 7) + 2;
            rv = ((csd[8] >> 6) | (csd[7] << 2) | ((csd[6] & 0x03) << 10)) + 1;
            rv <<= exponent;
            break;

        case 1:
            /* CSD version 2.0 (SDHC/SDXC)
               C_SIZE is bits 48-69 of the CSD, card size is calculated as
               (C_SIZE + 1) * 512KiB */
            rv = ((((uint64)csd[9]) | (uint64)(csd[8] << 8) |
                   ((uint64)(csd[7] & 0x3F) << 16)) + 1) << 19;
            break;

        default:
            /* Unknown version, punt. */
            rv = (uint64)-1;
            errno = ENODEV;
            goto out;
    }

out:
    spi_set_cs(false);
    spi_rw_byte(0xFF);

    return rv;
}

static int sdb_init(kos_blockdev_t *d) {
    (void)d;

    if(!initted) {
        errno = ENODEV;
        return -1;
    }

    return 0;
}

static int sdb_shutdown(kos_blockdev_t *d) {
    free(d->dev_data);
    return 0;
}

static int sdb_read_blocks(kos_blockdev_t *d, uint64_t block, size_t count,
                           void *buf) {
    sd_devdata_t *data = (sd_devdata_t *)d->dev_data;

    return sd_read_blocks(block + data->start_block, count, (uint8 *)buf);
}

static int sdb_write_blocks(kos_blockdev_t *d, uint64_t block, size_t count,
                            const void *buf) {
    sd_devdata_t *data = (sd_devdata_t *)d->dev_data;

    return sd_write_blocks(block + data->start_block, count,
                           (const uint8 *)buf);
}

static uint64_t sdb_count_blocks(kos_blockdev_t *d) {
    sd_devdata_t *data = (sd_devdata_t *)d->dev_data;

    return data->block_count;
}

static int sdb_flush(kos_blockdev_t *d) {
    /* Cache? We don't need no steenkin' cache! */
    (void)d;
    return 0;
}

static kos_blockdev_t sd_blockdev = {
    NULL,                   /* dev_data */
    9,                      /* l_block_size (block size of 512 bytes) */
    &sdb_init,              /* init */
    &sdb_shutdown,          /* shutdown */
    &sdb_read_blocks,       /* read_blocks */
    &sdb_write_blocks,      /* write_blocks */
    &sdb_count_blocks,      /* count_blocks */
    &sdb_flush              /* flush */
};

int sd_blockdev_for_partition(int partition, kos_blockdev_t *rv,
                              uint8 *partition_type) {
    uint8 buf[512];
    int pval;
    sd_devdata_t *ddata;

    if(!initted) {
        errno = ENXIO;
        return -1;
    }

    if(!rv || !partition_type) {
        errno = EFAULT;
        return -1;
    }

    /* Make sure the partition asked for is sane */
    if(partition < 0 || partition > 3) {
        dbglog(DBG_DEBUG, "Invalid partition number given: %d\n", partition);
        errno = EINVAL;
        return -1;
    }

    /* Read the MBR from the card */
    if(sd_read_blocks(0, 1, buf)) {
        return -1;
    }

    /* Make sure the SD card uses MBR partitions.
       TODO: Support GPT partitioning at some point. */
    if(buf[0x01FE] != 0x55 || buf[0x1FF] != 0xAA) {
        dbglog(DBG_DEBUG, "SD card doesn't appear to have a MBR\n");
        errno = ENOENT;
        return -1;
    }

    /* Figure out where the partition record we're concerned with is, and make
       sure that the partition actually exists. */
    pval = 16 * partition + 0x01BE;

    if(buf[pval + 4] == 0) {
        dbglog(DBG_DEBUG, "Partition %d appears to be empty\n", partition);
        errno = ENOENT;
        return -1;
    }

    /* Allocate the device data */
    if(!(ddata = (sd_devdata_t *)malloc(sizeof(sd_devdata_t)))) {
        errno = ENOMEM;
        return -1;
    }

    /* Copy in the template block device and fill it in */
    memcpy(rv, &sd_blockdev, sizeof(kos_blockdev_t));
    ddata->block_count = buf[pval + 0x0C] | (buf[pval + 0x0D] << 8) |
        (buf[pval + 0x0E] << 16) | (buf[pval + 0x0F] << 24);
    ddata->start_block = buf[pval + 0x08] | (buf[pval + 0x09] << 8) |
        (buf[pval + 0x0A] << 16) | (buf[pval + 0x0B] << 24);
    rv->dev_data = ddata;
    *partition_type = buf[pval + 4];

    return 0;
}

int sd_blockdev_for_device(kos_blockdev_t *rv) {
    sd_devdata_t *ddata;

    if (!initted) {
        errno = ENXIO;
        return -1;
    }

    if (!rv) {
        errno = EFAULT;
        return -1;
    }

    /* Allocate the device data */
    if (!(ddata = (sd_devdata_t *)malloc(sizeof(sd_devdata_t)))) {
        errno = ENOMEM;
        return -1;
    }

    ddata->start_block = 0;
    ddata->block_count = (sd_get_size() / 512);
    rv->dev_data = ddata;

    return 0;
}
